"use strict";(self.webpackChunk_playcanvas_blog=self.webpackChunk_playcanvas_blog||[]).push([[93071],{80560:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var a=t(74848),s=t(28453);const i={authors:"will",slug:"porting-a-large-es5-javascript-library-to-es6-modules-and-rollup",title:"Porting a Large ES5 JavaScript Library to ES6 Modules and Rollup",tags:["engine","javascript"]},r=void 0,l={permalink:"/porting-a-large-es5-javascript-library-to-es6-modules-and-rollup",editUrl:"https://github.com/playcanvas/blog/tree/main/blog/2020-06-19-porting-a-large-es5-javascript-library-to-es6-modules-and-rollup.md",source:"@site/blog/2020-06-19-porting-a-large-es5-javascript-library-to-es6-modules-and-rollup.md",title:"Porting a Large ES5 JavaScript Library to ES6 Modules and Rollup",description:"Since 2011, the PlayCanvas engine sourcebase has adhered strictly to the ES5 JavaScript specification. Since then, the JavaScript language and the surrounding tools ecosystem has moved on considerably. But PlayCanvas has steadfastly stuck to ES5. Why? Internet Explorer 11.",date:"2020-06-19T00:00:00.000Z",tags:[{label:"engine",permalink:"/tags/engine"},{label:"javascript",permalink:"/tags/javascript"}],readingTime:4.015,hasTruncateMarker:!1,authors:[{name:"Will Eastcott",title:"CEO",url:"https://twitter.com/willeastcott",imageURL:"https://pbs.twimg.com/profile_images/2635146631/edcd8b6dc4a34625770095941519ca8a_400x400.png",key:"will"}],frontMatter:{authors:"will",slug:"porting-a-large-es5-javascript-library-to-es6-modules-and-rollup",title:"Porting a Large ES5 JavaScript Library to ES6 Modules and Rollup",tags:["engine","javascript"]},unlisted:!1,prevItem:{title:"Plan Updates: More Storage, More Features, Same Price",permalink:"/plan-updates-more-storage-more-features-same-price"},nextItem:{title:"TANX lives! Popular WebGL online game returns",permalink:"/tanx-lives-popular-webgl-online-game-returns"}},o={authorsImageUrls:[void 0]},c=[{value:"What&#39;s Next?",id:"whats-next",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["Since 2011, the ",(0,a.jsx)(n.a,{href:"https://github.com/playcanvas/engine",children:"PlayCanvas engine sourcebase"})," has adhered strictly to the ES5 JavaScript specification. Since then, the JavaScript language and the surrounding tools ecosystem has moved on considerably. But PlayCanvas has steadfastly stuck to ES5. Why? Internet Explorer 11."]}),"\n",(0,a.jsxs)(n.p,{children:["IE11 was released on October 17, 2013. But even today, ",(0,a.jsx)(n.a,{href:"https://gs.statcounter.com/browser-version-market-share/desktop/worldwide/#monthly-201905-202005",children:"StatCounter"})," reports that IE11 has 2.43% of the global desktop browser market. Since PlayCanvas content is viewed by 100s of millions of end users, this is a pretty big deal."]}),"\n",(0,a.jsx)(n.p,{children:"Over time, the engine codebase has grown significantly. It's now nearly 100,000 lines long. Maintaining and building such a large codebase can be problematic. To help bring some level of consistency and structure, we imposed the following pattern:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"Object.assign(pc, (function () {\n    var SomeClass = function () {\n        this.other = new pc.OtherClass();\n    };\n\n    Object.assign(SomeClass.prototype, {\n        someFunction: function () {}\n    });\n\n    return {\n        SomeClass: SomeClass\n    };\n}()));\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"pc"})," is the PlayCanvas library namespace. So a developer would create instances of this class as follows:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"var thing = new pc.SomeClass();\n"})}),"\n",(0,a.jsx)(n.p,{children:"To build the engine, we wrote a node.js script which would parse a list of dependencies (JavaScript filenames) and concatenate them. There were several problems:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"The pattern above is overly verbose making it harder to inspect the code."}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Object.assign"})," needs to be called 250 times when the library is initially executed by the browser, once for each module. This increases app start-up times."]}),"\n",(0,a.jsxs)(n.li,{children:["In internal engine code, all class names and constants need to be accessed via the ",(0,a.jsx)(n.code,{children:"pc"})," namespace. This is because the internals of the pattern above cannot see the internals of other modules and vice versa. This bloats the engine code and slows things down."]}),"\n",(0,a.jsx)(n.li,{children:"The dependencies file had to be carefully manually ordered to ensure things were declared in the right order."}),"\n",(0,a.jsx)(n.li,{children:"The build script itself was about 1000 lines of JavaScript which carried its own maintenance overhead."}),"\n",(0,a.jsx)(n.li,{children:"Unused code was being included in the published engine."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"We believed the solution to these problems was to migrate the engine codebase from vanilla ES5 to ES6 modules. This would transform the original module pattern to:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"import { OtherClass } from './other-class.js';\n\nvar SomeClass = function () {\n    this.other = new OtherClass();\n};\n\nObject.assign(SomeClass.prototype, {\n    someFunction: function () {}\n});\n\nexport { SomeClass };\n"})}),"\n",(0,a.jsx)(n.p,{children:"Much better!"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"No more needless calls to Object.assign to the pc namespace."}),"\n",(0,a.jsx)(n.li,{children:"No further need to use the pc namespace within modules."}),"\n",(0,a.jsx)(n.li,{children:"Dependencies are explicitly described in each JS file."}),"\n",(0,a.jsx)(n.li,{children:"Only what is necessary is exported from modules (and the overall engine)."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"But what about IE11? It doesn't understand ES6 module syntax! \ud83d\ude31 PlayCanvas still needs to ship as a strictly ES5 library. To transform the entire codebase from ES6 module format to ES5 UMD format (PlayCanvas is used in both the browser and Node), you simply need to leverage a JavaScript bundler."}),"\n",(0,a.jsx)(n.p,{children:"There are many options for selecting a JS bundler. In the end, 3 options were tested: Rollup, Parcel and ESBuild. You can see the PRs for each here:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Rollup: ",(0,a.jsx)(n.a,{href:"https://github.com/playcanvas/engine/pull/2166",children:"https://github.com/playcanvas/engine/pull/2166"})]}),"\n",(0,a.jsxs)(n.li,{children:["Parcel: ",(0,a.jsx)(n.a,{href:"https://github.com/playcanvas/engine/pull/2106",children:"https://github.com/playcanvas/engine/pull/2106"})]}),"\n",(0,a.jsxs)(n.li,{children:["ESBuild: ",(0,a.jsx)(n.a,{href:"https://github.com/playcanvas/engine/pull/2115",children:"https://github.com/playcanvas/engine/pull/2115"})]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"In the end, Rollup was selected over Parcel and ESBuild. In testing, Parcel needed up to 16s for an initial build, while Rollup only required 3s. And we were reticent to adopt ESBuild since it was far less established and battle tested compared to Rollup. But we may review this decision in the future. Now that the engine is ported to ES6 modules, switching bundler is fairly straightforward."}),"\n",(0,a.jsx)(n.p,{children:"With Rollup, the build script reduced from ~1000 lines to ~100 lines. Quite a saving. Rollup's plugin system made it incredibly easy to write custom handling for GLSL files and also run a C-like preprocessor in order to build debug, release and profile versions of the engine."}),"\n",(0,a.jsx)(n.h2,{id:"whats-next",children:"What's Next?"}),"\n",(0,a.jsx)(n.p,{children:"Now that we have merged the ES6 Module port, where do we go from here?"}),"\n",(0,a.jsx)(n.p,{children:"First up, Rollup is kindly informing us that circular dependencies exist in the PlayCanvas codebase."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"Rollup Circular Dependencies",src:t(98285).A+"",width:"1082",height:"226"})}),"\n",(0,a.jsxs)(n.p,{children:["We want to clean things up and eliminate them. What's the motivation for that? It makes it easier for the bundler to employ tree-shaking to remove unreferenced code from the engine. At the moment, the engine's ",(0,a.jsx)(n.code,{children:"Application"})," class imports pretty much everything. And many classes import the ",(0,a.jsx)(n.code,{children:"Application"}),". This makes it hard to build a version of the library which doesn't include the particle engine, say. Or maybe the physics engine."]}),"\n",(0,a.jsxs)(n.p,{children:["Beyond that, we are keen to explore leaving ES5 behind and fully embracing 'modern' JavaScript, or maybe TypeScript. Rollup can trivially run Babel or the TypeScript compiler as plugins, thereby ensuring we can still ship an ES5 library. We're looking forward to making that decision based on your feedback. So feel free to let us know what you think on the ",(0,a.jsx)(n.a,{href:"https://forum.playcanvas.com/",children:"forum"}),"!"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},98285:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/engine-circular-dependencies-a04ed6499bff366476a7840f0cca685a.png"},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var a=t(96540);const s={},i=a.createContext(s);function r(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);